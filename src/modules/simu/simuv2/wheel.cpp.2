/***************************************************************************

    file                 : wheel.cpp
    created              : Sun Mar 19 00:09:06 CET 2000
    copyright            : (C) 2000 by Eric Espie
    email                : torcs@free.fr
    version              : $Id$

 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#include <stdio.h>
#include "sim.h"

static char *WheelSect[4] = {SECT_FRNTRGTWHEEL, SECT_FRNTLFTWHEEL, SECT_REARRGTWHEEL, SECT_REARLFTWHEEL};
static char *SuspSect[4] = {SECT_FRNTRGTSUSP, SECT_FRNTLFTSUSP, SECT_REARRGTSUSP, SECT_REARLFTSUSP};
static char *BrkSect[4] = {SECT_FRNTRGTBRAKE, SECT_FRNTLFTBRAKE, SECT_REARRGTBRAKE, SECT_REARLFTBRAKE};

/* #define RELAXATION(target, prev, amount) {(target) = (prev) + (amount) * ((target) - (prev)) * SimDeltaTime; (prev) = (target);} */

void
SimWheelConfig(tCar *car, int index)
{
    void   *hdle = car->params;
    tCarElt *carElt = car->carElt;
    tWheel *wheel = &(car->wheel[index]);
    tdble rimdiam, tirewidth, tireratio, pressure;
    tdble x0, Ca, RFactor, EFactor, patchLen;

    pressure              = GfParmGetNum(hdle, WheelSect[index], PRM_PRESSURE, (char*)NULL, 275600);
    rimdiam               = GfParmGetNum(hdle, WheelSect[index], PRM_RIMDIAM, (char*)NULL, 0.33);
    tirewidth             = GfParmGetNum(hdle, WheelSect[index], PRM_TIREWIDTH, (char*)NULL, 0.145);
    tireratio             = GfParmGetNum(hdle, WheelSect[index], PRM_TIRERATIO, (char*)NULL, .75);
    wheel->mu             = GfParmGetNum(hdle, WheelSect[index], PRM_MU, (char*)NULL, 1.0);
    wheel->I              = GfParmGetNum(hdle, WheelSect[index], PRM_INERTIA, (char*)NULL, 1.5);
    wheel->I += wheel->brake.I; /* add brake inertia */
    wheel->staticPos.y    = GfParmGetNum(hdle, WheelSect[index], PRM_YPOS, (char*)NULL, 0);
    x0			  = GfParmGetNum(hdle, WheelSect[index], PRM_RIDEHEIGHT, (char*)NULL, 0.20);
    wheel->staticPos.az   = GfParmGetNum(hdle, WheelSect[index], PRM_TOE, (char*)NULL, 0.0);
    Ca                    = GfParmGetNum(hdle, WheelSect[index], PRM_CA, (char*)NULL, 30.0);
    RFactor               = GfParmGetNum(hdle, WheelSect[index], PRM_RFACTOR, (char*)NULL, 0.8);
    EFactor               = GfParmGetNum(hdle, WheelSect[index], PRM_EFACTOR, (char*)NULL, 0.7);
    wheel->lfMax          = GfParmGetNum(hdle, WheelSect[index], PRM_LOADFMAX, (char*)NULL, 1.6);
    wheel->lfMin          = GfParmGetNum(hdle, WheelSect[index], PRM_LOADFMIN, (char*)NULL, 0.8);
    wheel->opLoad         = GfParmGetNum(hdle, WheelSect[index], PRM_OPLOAD, (char*)NULL, wheel->weight0*1.2);
    wheel->mass           = GfParmGetNum(hdle, WheelSect[index], PRM_MASS, (char*)NULL, 20.0);

    wheel->lfMin = MIN(0.99, wheel->lfMin);
    wheel->lfMax = MAX(1.01, wheel->lfMax);

    RFactor = MIN(1.0, RFactor);
    RFactor = MAX(0.1, RFactor);
    EFactor = MIN(1.0, EFactor);

    patchLen = wheel->weight0 / (tirewidth * pressure);
    
    wheel->radius = rimdiam / 2.0 + tirewidth * tireratio;
    wheel->tireSpringRate = wheel->weight0 / (wheel->radius * (1.0 - cos(asin(patchLen / (2.0 * wheel->radius)))));
    wheel->relPos.x = wheel->staticPos.x = car->axle[index/2].xpos;
    wheel->relPos.y = wheel->staticPos.y;
    wheel->relPos.z = wheel->radius - wheel->susp.spring.x0;
    wheel->relPos.ax = wheel->relPos.ay = wheel->relPos.az = 0;
    wheel->steer = 0;

    /* components */
    SimSuspConfig(hdle, SuspSect[index], &(wheel->susp), wheel->weight0, x0);
    SimBrakeConfig(hdle, BrkSect[index], &(wheel->brake));
    
    carElt->_rimRadius(index) = rimdiam * .5;
    carElt->_tireHeight(index) = tirewidth * tireratio;
    carElt->_tireWidth(index) = tirewidth;
    carElt->_brakeDiskRadius(index) = wheel->brake.radius;
    carElt->_wheelRadius(index) = wheel->radius;

    wheel->mfC = 2 - asin(RFactor) * 2 / PI;
    wheel->mfB = Ca / wheel->mfC;
    wheel->mfE = EFactor;
    
    wheel->lfK = log((1 - wheel->lfMin) / (wheel->lfMax - wheel->lfMin));




    wheel->mut	= wheel->mu;
    wheel->mun	= wheel->mu;
    wheel->Kt	= 8000;
    wheel->Kn	= 8000;
    wheel->Ct	= 3000;
    wheel->Cn	= 3000;
    wheel->Kts	= 100;
    wheel->Kna	= 100;
    













}

void
SimWheelUpdateRide(tCar *car, int index)
{
    tWheel *wheel = &(car->wheel[index]);
    tdble Zroad;
    tdble prex;

    /* compute suspension travel */
    RtTrackGlobal2Local(car->trkPos.seg, wheel->pos.x, wheel->pos.y, &(wheel->trkPos), TR_LPOS_SEGMENT);
    wheel->zRoad = Zroad = RtTrackHeightL(&(wheel->trkPos));
    prex = wheel->susp.x;
    wheel->susp.x = wheel->rideHeight = wheel->pos.z - Zroad;
    /* verify the suspension travel */
    SimSuspCheckIn(&(wheel->susp));
    wheel->susp.v = (prex - wheel->susp.x) / SimDeltaTime;
    /* update wheel brake */
    SimBrakeUpdate(car, wheel, &(wheel->brake));
}

void
SimWheelUpdateForce(tCar *car, int index)
{
    tWheel 	*wheel = &(car->wheel[index]);
    tdble 	vt, vn; /* wheel related velocity */
    tdble 	Fn, Ft;
    tdble 	waz;
    tdble 	CosA, SinA;
    tdble	mut, mun, dDt, dDn, Fm2;

    wheel->state = 0;

    /* VERTICAL STUFF CONSIDERING SMALL PITCH AND ROLL ANGLES */
    /* update suspension force */
    SimSuspUpdate(&(wheel->susp));
    /* check suspension state */
    wheel->state |= wheel->susp.state;
    if ((wheel->state & SIM_SUSP_EXT) == 0) {
	wheel->forces.z = wheel->axleFz + wheel->susp.force;
	if (wheel->forces.z < 0) {
	    wheel->forces.z = 0;
	}
    } else {
	wheel->forces.z = 0;
    }

    /* update wheel coord */
    wheel->relPos.z = - wheel->susp.x / wheel->susp.spring.bellcrank + wheel->radius; /* center relative to GC */

    wheel->relPos.az = waz = wheel->steer + wheel->staticPos.az;

    if (wheel->forces.z == 0) {
	wheel->forces.x = 0;
	wheel->forces.y = 0;
	wheel->Dt	= 0;
	wheel->Dn	= 0;
	wheel->spinTq	= 0;
	wheel->sa	= 0;
	wheel->sx	= 0;
	return;
    }

    CosA = cos(waz);
    SinA = sin(waz);

    /* tangent velocity */
    vt = wheel->bodyVel.x * CosA + wheel->bodyVel.y * SinA;

    /* normal */
    vn = wheel->bodyVel.x * SinA - wheel->bodyVel.y * CosA;

    mut = wheel->mut * (wheel->lfMin + (wheel->lfMax - wheel->lfMin) * exp(wheel->lfK * wheel->forces.z / wheel->opLoad));
    mun = wheel->mun * (wheel->lfMin + (wheel->lfMax - wheel->lfMin) * exp(wheel->lfK * wheel->forces.z / wheel->opLoad));

    dDt = wheel->spinVel * wheel->radius - vt - wheel->Kts * fabs(wheel->spinVel) * wheel->Dt / (wheel->forces.z * mut);
    dDn = vn - wheel->Kna * fabs(wheel->spinVel) * wheel->Dn / (wheel->forces.z * mun);

    wheel->Dt = wheel->Dt + dDt * SimDeltaTime;
    wheel->Dn = wheel->Dn + dDn * SimDeltaTime;
    
    Ft = wheel->Kt * wheel->Dt + wheel->Ct * dDt;
    Fn = wheel->Kn * wheel->Dn + wheel->Cn * dDn;
    
    Fm2 = mut * mun * wheel->forces.z;
    Fm2 = Fm2 * Fm2;

    wheel->sa = wheel->sx = 0;
    
    if (((mun*mun*Ft*Ft) + (mut*mut*Fn*Fn)) > Fm2) {
	tdble nu = sqrt(Fm2 / ((mun*mun*Ft*Ft) + (mut*mut*Fn*Fn)));
	Ft = nu * Ft;
	Fn = nu * Fn;
	wheel->sa = wheel->sx = 1.0 / nu;
	wheel->Dt = Ft / wheel->Kt;
	wheel->Dn = Fn / wheel->Kn;
    }
    
    
    wheel->forces.x = Ft * CosA - Fn * SinA;
    wheel->forces.y = Ft * SinA + Fn * CosA;
    wheel->spinTq = Ft * wheel->radius;
}


#define RES_BRK_TQ	0.0	/* residual friction torque */
#define VT_LIMIT	0.0

static void
simUpdateFreeWheels(tCar *car, int axlenb)
{
    int			i;
    tWheel 		*wheel;
    tdble		BrTq;		/* brake torque */
    tdble		ndot;		/* rotation acceleration */
    tdble		I;
    
    for (i = axlenb * 2; i < axlenb * 2 + 2; i++) {
	wheel = &(car->wheel[i]);

	I = wheel->I + car->axle[axlenb].I;
	    
	ndot = SimDeltaTime * wheel->spinTq / I;
	wheel->spinVel -= ndot;
	BrTq = - SIGN(wheel->spinVel) * (wheel->brake.Tq + RES_BRK_TQ);
	
	ndot = SimDeltaTime * BrTq / I;

	if ((ndot * wheel->spinVel) < 0.0) {
	    if (fabs(ndot) > fabs(wheel->spinVel)) {
		ndot = -wheel->spinVel;
	    }
	}
	if ((wheel->spinVel == 0.0) && (ndot < 0.0)) ndot = 0;
	
	wheel->spinVel += ndot;
	if (fabs(wheel->vt) < VT_LIMIT) {
	    wheel->preSpinVel = wheel->spinVel = 0;
	}
    }
}

static void
simUpdateFreeDifferential(tCar *car, int axlenb)
{
    tdble		Ir, Il;
    tWheel 		*wheelr;
    tWheel 		*wheell;
    tdble		BrTq;		/* brake torque */
    tdble		DrTq;		/* Drive torque */
    tdble		ndotr, ndotl;	/* rotation acceleration */
    tdble		engineReaction;
    tdble		meanv;
    tTransmission	*trans = &(car->transmission);
    
    /* the 2 wheels have the same torque */
    wheelr = &(car->wheel[axlenb * 2]);
    wheell = &(car->wheel[axlenb * 2 + 1]);

    Ir = wheelr->I + (car->axle[axlenb].I + trans->curI)/2.0;
    Il = wheell->I + (car->axle[axlenb].I + trans->curI)/2.0;

    if (trans->clutch.state == CLUTCH_RELEASED) {
	DrTq = (car->engine.Tq * trans->curOverallRatio)/2.0;
    } else {
	DrTq = 0;
    }
    ndotr = SimDeltaTime * (DrTq - wheelr->spinTq) / Ir;
    wheelr->spinVel += ndotr;
    ndotl = SimDeltaTime * (DrTq - wheell->spinTq) / Il;
    wheell->spinVel += ndotl;

    BrTq = - SIGN(wheelr->spinVel) * (wheelr->brake.Tq);
    ndotr = SimDeltaTime * BrTq / Ir;
    if (((ndotr * wheelr->spinVel) < 0.0) && (fabs(ndotr) > fabs(wheelr->spinVel))) {
	ndotr = -wheelr->spinVel;
    }
    if ((wheelr->spinVel == 0.0) && (ndotr < 0.0)) ndotr = 0;
    wheelr->spinVel += ndotr;
	
    BrTq = - SIGN(wheell->spinVel) * (wheell->brake.Tq);
    ndotl = SimDeltaTime * BrTq / Il;
    if (((ndotl * wheell->spinVel) < 0.0) && (fabs(ndotl) > fabs(wheell->spinVel))) {
	ndotl = -wheell->spinVel;
    }
    if ((wheell->spinVel == 0.0) && (ndotl < 0.0)) ndotl = 0;
    wheell->spinVel += ndotl;
	
    meanv = (wheelr->spinVel+wheell->spinVel)/2.0;
    if (meanv != 0.0) {
	engineReaction = SimEngineUpdateRpm(car, meanv)/meanv;
	if (engineReaction != 0.0) {
	    wheell->spinVel *= engineReaction;
	    wheelr->spinVel *= engineReaction;
	}
    }
    if (DrTq == 0) {
	if (fabs(wheell->vt) < VT_LIMIT) {
	    wheell->preSpinVel = wheell->spinVel = 0;
	}
	if (fabs(wheelr->vt) < VT_LIMIT) {
	    wheelr->preSpinVel = wheelr->spinVel = 0;
	}
    }
}

static void
simUpdateSpoolDifferential(tCar *car, int axlenb)
{
    tdble		I;
    tWheel 		*wheelr;
    tWheel 		*wheell;
    tdble		BrTq;		/* brake torque */
    tdble		DrTq;		/* Drive torque */
    tdble		ndot;		/* rotation acceleration */
    tdble		engineReaction;
    tTransmission	*trans = &(car->transmission);

    /* the 2 wheels have same speed */
    wheelr = &(car->wheel[axlenb * 2]);
    wheell = &(car->wheel[axlenb * 2 + 1]);
	
    I = wheell->I + wheelr->I + car->axle[axlenb].I + trans->curI;

    if (trans->clutch.state == CLUTCH_RELEASED) {
	DrTq = car->engine.Tq * trans->curOverallRatio;
    } else {
	DrTq = 0;
    }
    ndot = SimDeltaTime * (DrTq - wheelr->spinTq - wheell->spinTq) / I;
    wheelr->spinVel += ndot;

    BrTq = - SIGN(wheelr->spinVel) * (wheelr->brake.Tq + wheell->brake.Tq + RES_BRK_TQ);
    ndot = SimDeltaTime * BrTq / I;

    if (((ndot * wheelr->spinVel) < 0.0) && (fabs(ndot) > fabs(wheelr->spinVel))) {
	ndot = -wheelr->spinVel;
    }
    if ((wheelr->spinVel == 0.0) && (ndot < 0.0)) ndot = 0;
	
    wheelr->spinVel += ndot;
    wheell->spinVel = wheelr->spinVel;
    engineReaction = SimEngineUpdateRpm(car, wheelr->spinVel);
    if (engineReaction != 0.0) {
	wheell->spinVel = wheelr->spinVel = engineReaction;
    }
    if (DrTq == 0) {
	if (fabs(wheell->vt) < VT_LIMIT) {
	    wheell->preSpinVel = wheell->spinVel = 0;
	}
	if (fabs(wheelr->vt) < VT_LIMIT) {
	    wheelr->preSpinVel = wheelr->spinVel = 0;
	}
    }
}


void
SimWheelUpdateRotation(tCar *car)
{
    int			i;
    tWheel 		*wheel;

    /* front wheels */
    switch (car->axle[0].differential.type) {
    case DIFF_NONE:
	simUpdateFreeWheels(car, 0);
	break;

    case DIFF_SPOOL:
	simUpdateSpoolDifferential(car, 0);
	break;

    case DIFF_FREE:
	simUpdateFreeDifferential(car, 0);
	break;
    }
    

    /* rear wheel */
    switch (car->axle[1].differential.type) {
    case DIFF_NONE:
	simUpdateFreeWheels(car, 1);
	break;	

    case DIFF_SPOOL:
	simUpdateSpoolDifferential(car, 1);
	break;

    case DIFF_FREE:
	simUpdateFreeDifferential(car, 1);
	break;
    }

    for (i = 0; i < 4; i++) {
	wheel = &(car->wheel[i]);
	RELAXATION(wheel->spinVel, wheel->preSpinVel, 50.0);
	wheel->relPos.ay += wheel->spinVel * SimDeltaTime;
	//NORM0_2PI(wheel->relPos.ay);
	car->carElt->_wheelSpinVel(i) = wheel->spinVel;
    }
}

